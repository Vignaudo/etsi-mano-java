/*
 * SOL003 - VNF Lifecycle Management interface
 * SOL003 - VNF Lifecycle Management interface definition  IMPORTANT: Please note that this file might be not aligned to the current version of the ETSI Group Specification it refers to. In case of discrepancies the published ETSI Group Specification takes precedence.  In clause 4.3.2 of ETSI GS NFV-SOL 003 v2.4.1, an attribute-based filtering mechanism is defined. This mechanism is currently not included in the corresponding OpenAPI design for this GS version. Changes to the attribute-based filtering mechanism are being considered in v2.5.1 of this GS for inclusion in the corresponding future ETSI NFV OpenAPI design. Please report bugs to https://forge.etsi.org/bugzilla/buglist.cgi?component=Nfv-Openapis&list_id=61&product=NFV&resolution=
 *
 * OpenAPI spec version: 1.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.ubiqube.etsi.mano.vnfm.v261.model.nslcm;

import java.util.ArrayList;
import java.util.List;

import javax.validation.constraints.NotNull;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;

import io.swagger.annotations.ApiModelProperty;

/**
 * SubscriptionAuthentication
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaJerseyServerCodegen", date = "2019-06-13T10:04:39.223+02:00")
public class SubscriptionAuthentication {
	/**
	 * Gets or Sets authType
	 */
	public enum AuthTypeEnum {
		BASIC("BASIC"),

		OAUTH2_CLIENT_CREDENTIALS("OAUTH2_CLIENT_CREDENTIALS"),

		TLS_CERT("TLS_CERT");

		private final String value;

		AuthTypeEnum(String value) {
			this.value = value;
		}

		@Override
		@JsonValue
		public String toString() {
			return String.valueOf(value);
		}

		@JsonCreator
		public static AuthTypeEnum fromValue(String text) {
			for (final AuthTypeEnum b : AuthTypeEnum.values()) {
				if (String.valueOf(b.value).equals(text)) {
					return b;
				}
			}
			return null;
		}
	}

	@JsonProperty("authType")
	private List<AuthTypeEnum> authType = new ArrayList<AuthTypeEnum>();

	@JsonProperty("paramsBasic")
	private SubscriptionAuthenticationParamsBasic paramsBasic = null;

	@JsonProperty("paramsOauth2ClientCredentials")
	private SubscriptionAuthenticationParamsOauth2ClientCredentials paramsOauth2ClientCredentials = null;

	public SubscriptionAuthentication authType(List<AuthTypeEnum> authType) {
		this.authType = authType;
		return this;
	}

	public SubscriptionAuthentication addAuthTypeItem(AuthTypeEnum authTypeItem) {
		this.authType.add(authTypeItem);
		return this;
	}

	/**
	 * Defines the types of Authentication / Authorization which the API consumer is
	 * willing to accept when receiving a notification. Permitted values: * BASIC:
	 * In every HTTP request to the notification endpoint, use HTTP Basic
	 * authentication with the client credentials. * OAUTH2_CLIENT_CREDENTIALS: In
	 * every HTTP request to the notification endpoint, use an OAuth 2.0 Bearer
	 * token, obtained using the client credentials grant type. * TLS_CERT: Every
	 * HTTP request to the notification endpoint is sent over a mutually
	 * authenticated TLS session, i.e. not only the server is authenticated, but
	 * also the client is authenticated during the TLS tunnel setup.
	 * 
	 * @return authType
	 **/
	@JsonProperty("authType")
	@ApiModelProperty(required = true, value = "Defines the types of Authentication / Authorization which the API consumer is willing to accept when receiving a notification. Permitted values: * BASIC: In every HTTP request to the notification endpoint, use   HTTP Basic authentication with the client credentials.  * OAUTH2_CLIENT_CREDENTIALS: In every HTTP request to the   notification endpoint, use an OAuth 2.0 Bearer token, obtained   using the client credentials grant type. * TLS_CERT: Every HTTP request to the notification endpoint is sent   over a mutually authenticated TLS session, i.e. not only the   server is authenticated, but also the client is authenticated   during the TLS tunnel setup. ")
	@NotNull
	public List<AuthTypeEnum> getAuthType() {
		return authType;
	}

	public void setAuthType(List<AuthTypeEnum> authType) {
		this.authType = authType;
	}

	public SubscriptionAuthentication paramsBasic(SubscriptionAuthenticationParamsBasic paramsBasic) {
		this.paramsBasic = paramsBasic;
		return this;
	}

	/**
	 * Get paramsBasic
	 * 
	 * @return paramsBasic
	 **/
	@JsonProperty("paramsBasic")
	@ApiModelProperty(value = "")
	public SubscriptionAuthenticationParamsBasic getParamsBasic() {
		return paramsBasic;
	}

	public void setParamsBasic(SubscriptionAuthenticationParamsBasic paramsBasic) {
		this.paramsBasic = paramsBasic;
	}

	public SubscriptionAuthentication paramsOauth2ClientCredentials(SubscriptionAuthenticationParamsOauth2ClientCredentials paramsOauth2ClientCredentials) {
		this.paramsOauth2ClientCredentials = paramsOauth2ClientCredentials;
		return this;
	}

	/**
	 * Get paramsOauth2ClientCredentials
	 * 
	 * @return paramsOauth2ClientCredentials
	 **/
	@JsonProperty("paramsOauth2ClientCredentials")
	@ApiModelProperty(value = "")
	public SubscriptionAuthenticationParamsOauth2ClientCredentials getParamsOauth2ClientCredentials() {
		return paramsOauth2ClientCredentials;
	}

	public void setParamsOauth2ClientCredentials(SubscriptionAuthenticationParamsOauth2ClientCredentials paramsOauth2ClientCredentials) {
		this.paramsOauth2ClientCredentials = paramsOauth2ClientCredentials;
	}

	@Override
	public String toString() {
		final StringBuilder sb = new StringBuilder();
		sb.append("class SubscriptionAuthentication {\n");

		sb.append("    authType: ").append(toIndentedString(authType)).append("\n");
		sb.append("    paramsBasic: ").append(toIndentedString(paramsBasic)).append("\n");
		sb.append("    paramsOauth2ClientCredentials: ").append(toIndentedString(paramsOauth2ClientCredentials)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(java.lang.Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}
}
